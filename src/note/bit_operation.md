# 位运算


为什么一个数 & 32 可以检测出来第五位置是不是0?
```
举例说明
假设我们有一个数 x，我们想检测它的第五位是否为1。

例子1: x = 42，二进制表示为 0010 1010。
   0010 1010  (42)
&  0010 0000  (32)
-------------
   0010 0000  (32)  // 第五位是1，结果是32
例子2: x = 10，二进制表示为 0000 1010。
   0000 1010  (10)
&  0010 0000  (32)
-------------
   0000 0000  (0)   // 第五位是0，结果是0
从上面的例子可以看出，当 x 的第五位为1时，x & 32 的结果为32；当第五位为0时，结果为0。

代码示例
在 Rust 中，你可以使用如下代码来检测一个数的第五位：

fn is_fifth_bit_set(x: u32) -> bool {
    x & 32 != 0
}

fn main() {
    let number1 = 42;
    let number2 = 10;

    println!("Is the fifth bit of {} set? {}", number1, is_fifth_bit_set(number1));
    println!("Is the fifth bit of {} set? {}", number2, is_fifth_bit_set(number2));
}
运行结果：
```