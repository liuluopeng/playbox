### 什么样的程序能称其为 算法


- 有输入

- 有输出

- 正确性

- 确定性 算法是一系列的指令

- 可行性 每一个基本操作都能实现（把大象关进冰箱）    在常数时间内完成

- 又穷性 能够结束





编写代码实现下面这样一个序列：

HailStone序列:


 - n=1时，返回1；
 - n>1时且为偶数时，{n} $\cup$ {n/2}
 - n>1时且为奇数时，{n} $\cup$ {3n + 1}

$$\sum_{n=1}^\infty k$$




```c++
// ./code/hailstone.cpp
// 求序列hailstone(n) 的长度
int hailstone(int n)
{

    int count = 1;

    while (n > 1)
    {
        n % 2 == 1 ? n = 3 *n + 1 : n /= 2;
        count++;
    }

    return count;
}
```


显而易见，对于2的幂次方，序列很规整。

比如 `hailstone(16) = {16, 8, 4, 2, 1}`

但是，对一些数就很长，数字也不确定。

比如 `hailstone(7) == {7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, ...}`

目前，尚不能证明这个序列一定有穷，所以，这块代码未必能是一个算法。




什么是一个好的算法:

- 正确
    - 能处理 简单的/大规模的/一般性的/退化的/任意合法的输入

- 健壮 
    - 遇到不合法的输入能退出 而不是崩溃

- 可读 别人能看懂

- 效率
    - 时间尽可能少
    - 储存空间尽可能小





图灵机


[bilibili](https://www.bilibili.com)



生命游戏 

[睡前消息103](http://www.baidu.com)


尺子



评价算法好坏 需要有一个可度量的量

```
To measure if to know.
If you can not measure it, you can not improve it.

```

有了可以定量的指标，才能精确的评价事物发展到了哪个地步。


算法的成本

- 运行时间
- 所需的存储空间


那么，执行时间可以作为评价算法好坏的指标吗？

不太合适，因为不同机器的执行速度不尽相同。所以，应当存在一个指标，它可以消除机器差异造成的影响，这个指标在不同机器上得到了相同的值。或者说，这个指标根本不在乎机器的性能。

对于在很多机器上执行的同一个算法、以及同一个算法针对不同的输入，都可以归纳、概括出一个指标。

用 划分等价类 的办法。

显然，计算规模变大，计算成本也会变大。


特定算法 + 不同实例

对于一些特例，计算成本会与其他的普通实例，结果有很大的差异。


最坏情况

T(n) = max { T(P) | |P|=n}


特定问题 + 不同算法

能否用统计得出算法的性能？

- 不同的算法，不同的输入
- 不同的算法，不同类型的输入






nlogn  application
逆序对： 衡量有序的程度
取出来数组中第n大的元素

  
