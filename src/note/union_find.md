# union find

## union find 
解决问题的过程中有没有顺便解决了别的问题？

- 查找一个元素的存在与否  
    - 使用顺序查找  
- 查找一个元素的排名  
    - 排序之后再查找顺序 
- 查找两点连不连通  
    - 给出两点的路径 


第一个实现 用一个数组

```
index  1 2 3 4 5 6 7 8 9 
      [0 1 0 1 0 1 0 1 0]
```

操作：
- 查找
- 并 

另一个实现 常规实现  包含父亲的信息

```
        0 1 2 3 4 5 6 7 8 9 
parent  0 1 2 3 4 5 6 7 8 9 
```

A、B连接再一起：  A、B拥有相同的根。

优先让两个根连接，能降低树的高度。

- 针对size的优化
    - 把元素少的集合 指向 元素多的集合。 变得很快了。可以接受这样的速度了。

    








